lib.num_threads() =  1
#INFO: **** input file is /Users/zehaozhou/project/davidson/davidson/Davidson.py ****
import time
import numpy as np
from opt_einsum import contract as einsum
import pyscf
from pyscf import gto, scf, dft, tddft, data, lib
import argparse
import os
import yaml
from pyscf.tools import molden

lib.num_threads(1)
print ('lib.num_threads() = ', lib.num_threads())

parser = argparse.ArgumentParser(description='Davidson')
parser.add_argument('-x', '--xyzfile',        type=str, default='NA', help='xyz filename (molecule.xyz)')
parser.add_argument('-chk', '--checkfile',    type=str, default='NA', help='checkpoint filename (.chk)')
parser.add_argument('-m', '--method',         type=str, default='NA', help='RHF RKS UHF UKS')
parser.add_argument('-f', '--functional',     type=str, default='NA', help='xc functional')
parser.add_argument('-b', '--basis_set',      type=str, default='NA', help='basis sets')
parser.add_argument('-df', '--density_fit',   type=bool, default=False, help='density fitting turn on')
parser.add_argument('-g', '--grid_level',     type=int, default='3', help='0-9, 9 is best')
parser.add_argument('-i', '--initial_guess',  type=str, default='sTDA', help='initial guess: Adiag or sTDA')
parser.add_argument('-p', '--preconditioner', type=str, default='sTDA', help='preconditioner: Adiag or sTDA')
parser.add_argument('-t', '--tolerance',      type=float, default= 1e-5, help='residual norm convergence threshold')
parser.add_argument('-n', '--nstates',        type=int, default= 4, help='number of excited states')
parser.add_argument('-C', '--compare',        type=bool, default = False , help='whether to compare with PySCF TDA-TDDFT')
args = parser.parse_args()
################################################
# read xyz file and delete its first two lines
basename = args.xyzfile.split('.',1)[0]

f = open(args.xyzfile)
atom_coordinates = f.readlines()
del atom_coordinates[:2]
###########################################################################
# build geometry in PySCF
mol = gto.Mole()
mol.atom = atom_coordinates
mol.basis = args.basis_set
mol.verbose = 5
mol.build(parse_arg = False)
###########################################################################
###################################################
#DFT or HF?
if args.method == 'RKS':
    mf = dft.RKS(mol)
elif args.method == 'UKS':
    mf = dft.UKS(mol)
elif args.method == 'RHF':
    mf = scf.RHF(mol)
elif args.method == 'UHF':
    mf = scf.UHF(mol)

if 'KS' in args.method:
    mf.xc = args.functional
    mf.grids.level = args.grid_level
    # 0-9, big number for large mesh grids, default is 3

if args.density_fit:
    mf = mf.density_fit()

if args.checkfile != 'NA':
    mf.chkfile = args.checkfile
    mf.init_guess = 'chkfile'

mf.conv_tol = 1e-10


print ('Molecule built')
print ('Calculating SCF Energy...')
kernel_0 = time.time()
mf.kernel()
kernel_1 = time.time()
kernel = round (kernel_1 - kernel_0, 4)
print ('SCF Done after ', kernel, 'seconds')

mo_occ = mf.mo_occ



########################################################################
# Collect everything needed from PySCF
Qstart = time.time()
# extract vind() function
td = tddft.TDA(mf)

vind, hdiag = td.gen_vind(mf)

# vind (V) = A*V
def matrix_vector(V):
    return vind(V.T).T

Natm = mol.natm


occupied = len(np.where(mo_occ > 0)[0])
#mf.mo_occ is an array of occupance [2,2,2,2,2,0,0,0,0.....]
virtual = len(np.where(mo_occ == 0)[0])

# AO = [int(i.split(' ',1)[0]) for i in mol.ao_labels()]
# # .split(' ',1) is to split each element by space, split once.
# # mol.ao_labels() it is Labels of AO basis functions
# # AO is a list of corresponding atom_id

N_bf = len(mo_occ)
R = pyscf.gto.mole.inter_distance(mol, coords=None)
#Inter-particle distance array
# unit == ’Bohr’, Its value is 5.29177210903(80)×10^(−11) m
########################################################################


##################################################################################################
# create a function for dictionary of chemical hardness, by mappig two iteratable subject, list
# list of elements



elements = ['H' , 'He', 'Li', 'Be', 'B' , 'C' , 'N' , 'O' , 'F' , 'Ne',
    'Na', 'Mg', 'Al', 'Si', 'P' , 'S' , 'Cl', 'Ar', 'K' , 'Ca',
    'Sc', 'Ti', 'V' , 'Cr', 'Mn', 'Fe', 'Co', 'Ni', 'Cu', 'Zn',
    'Ga', 'Ge', 'As', 'Se', 'Br', 'Kr', 'Rb', 'Sr', 'Y' , 'Zr',
    'Nb', 'Mo', 'Tc', 'Ru', 'Rh', 'Pd', 'Ag', 'Cd', 'In', 'Sn',
    'Sb', 'Te', 'I' , 'Xe', 'Cs', 'Ba', 'La', 'Ce', 'Pr', 'Nd',
    'Pm', 'Sm', 'Eu', 'Gd', 'Tb', 'Dy', 'Ho', 'Er', 'Tm', 'Yb',
    'Lu', 'Hf', 'Ta', 'W' , 'Re', 'Os', 'Ir', 'Pt', 'Au', 'Hg',
    'Tl', 'Pb', 'Bi', 'Po', 'At', 'Rn', 'Fr', 'Ra', 'Ac', 'Th',
    'Pa', 'U' , 'Np', 'Pu']
#list of chemical hardness, they are floats, containing elements 1-94, in Hartree
hardness = [
0.47259288,
0.92203391,
0.17452888,
0.25700733,
0.33949086,
0.42195412,
0.50438193,
0.58691863,
0.66931351,
0.75191607,
0.17964105,
0.22157276,
0.26348578,
0.30539645,
0.34734014,
0.38924725,
0.43115670,
0.47308269,
0.17105469,
0.20276244,
0.21007322,
0.21739647,
0.22471039,
0.23201501,
0.23933969,
0.24665638,
0.25398255,
0.26128863,
0.26859476,
0.27592565,
0.30762999,
0.33931580,
0.37235985,
0.40273549,
0.43445776,
0.46611708,
0.15585079,
0.18649324,
0.19356210,
0.20063311,
0.20770522,
0.21477254,
0.22184614,
0.22891872,
0.23598621,
0.24305612,
0.25013018,
0.25719937,
0.28784780,
0.31848673,
0.34912431,
0.37976593,
0.41040808,
0.44105777,
0.05019332,
0.06762570,
0.08504445,
0.10247736,
0.11991105,
0.13732772,
0.15476297,
0.17218265,
0.18961288,
0.20704760,
0.22446752,
0.24189645,
0.25932503,
0.27676094,
0.29418231,
0.31159587,
0.32902274,
0.34592298,
0.36388048,
0.38130586,
0.39877476,
0.41614298,
0.43364510,
0.45104014,
0.46848986,
0.48584550,
0.12526730,
0.14268677,
0.16011615,
0.17755889,
0.19497557,
0.21240778,
0.07263525,
0.09422158,
0.09920295,
0.10418621,
0.14235633,
0.16394294,
0.18551941,
0.22370139]
HARDNESS = dict(zip(elements,hardness))
#function to return chemical hardness from dictionary HARDNESS
def Hardness (atom_id):
    atom = mol.atom_pure_symbol(atom_id)
    return HARDNESS[atom]
# mol.atom_pure_symbol(atom_id) returns pure element symbol, no special characters


########################################################################
# This block is the function to produce orthonormalized coefficient matrix C
def matrix_power (S,a):
    s,ket = np.linalg.eigh(S)
    s = s**a
    X = np.linalg.multi_dot([ket,np.diag(s),ket.T])
    #X == S^1/2
    return X

def orthonormalize (C):
    X = matrix_power(mf.get_ovlp(), 0.5)
    # S = mf.get_ovlp() #.get_ovlp() is basis overlap matrix
    # S = np.dot(np.linalg.inv(c.T), np.linalg.inv(c))
    C = np.dot(X,C)
    return C

C = mf.mo_coeff
# mf.mo_coeff is the coefficient matrix

C = orthonormalize (C)
# C is orthonormalized coefficient matrix
# np.dot(C.T,C) is a an identity matrix
########################################################################
Functionals = [
'lc-b3lyp',
'wb97',
'wb97x',
'wb97x-d3',
'cam-b3lyp']

parameters = [
[0.53, 8.00, 4.50],
[0.61, 8.00, 4.41],
[0.56, 8.00, 4.58],
[0.51, 8.00, 4.51],
[0.38, 1.86, 0.90]]
Functionals_parameters = dict(zip(Functionals, parameters))

if args.functional in Functionals:
    a_x, beta, alpha = Functionals_parameters[args.functional]
else:
    a_x, beta, alpha = [0.56, 8.00, 4.58]

# creat \eta matrix
a = [Hardness (atom_id) for atom_id in range (Natm)]
a = np.asarray(a).reshape(1,-1)
eta = (a+a.T)/2

# creat GammaK and GammaK matrix
GammaJ = (R**beta + (a_x * eta)**(-beta))**(-1/beta)
GammaK = (R**alpha + eta**(-alpha)) **(-1/alpha)


Natm = mol.natm
def generateQ ():
    aoslice = mol.aoslice_by_atom()
    q = np.zeros([Natm, N_bf, N_bf])
    #N_bf is number Atomic orbitals, occupied+virtual, q is same size with C
    for atom_id in range (0, Natm):
        shst, shend, atstart, atend = aoslice[atom_id]
        q[atom_id,:, :] = np.dot(C[atstart:atend, :].T, C[atstart:atend, :])
    return q

q_tensors = generateQ()



q_tensor_ij = np.zeros((Natm, occupied, occupied))
q_tensor_ij[:,:,:] = q_tensors[:, :occupied,:occupied]

q_tensor_ab = np.zeros((Natm, virtual, virtual))
q_tensor_ab[:,:,:] = q_tensors[:, occupied:,occupied:]

q_tensor_ia = np.zeros((Natm, occupied, virtual))
q_tensor_ia[:,:,:] = q_tensors[:, :occupied,occupied:]


Q_K = einsum('Bjb, AB -> Ajb', q_tensor_ia, GammaK)
Q_J = einsum('Bab, AB -> Aab', q_tensor_ab, GammaJ)
# pre-calculate and store the Q-Gamma rank 3 tensor
Qend = time.time()

Q_time = Qend - Qstart
print ('Q-Gamma tensors building time =', round(Q_time, 4))
##################################################################################################


###################################################################################################
# This block is to define on-the-fly two electron intergeral (pq|rs)
# A_iajb * v = delta_ia_ia*v + 2(ia|jb)*v - (ij|ab)*v

# iajb_v = einsum('Aia, Bjb, AB, jbm -> iam', q_tensor_ia, q_tensor_ia, GammaK, V)
# ijab_v = einsum('Aij, Bab, AB, jbm -> iam', q_tensor_ij, q_tensor_ab, GammaJ, V)

def iajb_fly (V):
    V = V.reshape(occupied, virtual, -1)
    Q_K_V = einsum('Ajb, jbm -> Am', Q_K, V)
    iajb_V = einsum('Aia, Am -> iam', q_tensor_ia, Q_K_V).reshape(occupied*virtual, -1)

    return iajb_V

def ijab_fly (V):
    V = V.reshape(occupied, virtual, -1)
    # (-1, occupied, virtual)
#     ijab_v = einsum('Aij, Aab, jbm -> iam', q_tensor_ij, Q_J,  V)

    # contract smaller index first
    # Aij_V = einsum('Aij, jbm -> Aibm', q_tensor_ij, V)
    # ijab_V = einsum('Aab, Aibm -> iam', Q_J, Aij_V).reshape(occupied*virtual, -1)

    # contract larger index first
    Aab_V = einsum('Aab, jbm -> jAam', Q_J, V)
    #('Aab, mjb -> mjaA')
    ijab_V = einsum('Aij, jAam -> iam', q_tensor_ij, Aab_V).reshape(occupied*virtual, -1)
    #('Aij, mjaA -> mia)
    return ijab_V

delta_diag_A = hdiag.reshape(occupied, virtual)



def delta_fly (V):
    V = V.reshape(occupied, virtual, -1)
    delta_v = einsum('ia,iam -> iam', delta_diag_A, V).reshape(occupied*virtual, -1)
    return delta_v

def sTDA_fly (V):
    # sTDA_A * V
    V = V.reshape(occupied*virtual,-1)
    # this feature can deal with multiple vectors
    sTDA_V =  delta_fly (V) + 2*iajb_fly (V) - ijab_fly (V)
    return sTDA_V
###################################################################################################





##############################################################################################
# orthonormalization of guess_vectors
def Gram_Schdmit_bvec (A, bvec):
    # suppose A is orthonormalized
    projections_coeff = np.dot(A.T, bvec)
    bvec = bvec - np.dot(A, projections_coeff)
    return bvec

def Gram_Schdmit (A):
    # A matrix has J columns, orthonormalize each columns
    # unualified vectors will be removed
    N_rows = np.shape(A)[0]
    N_vectors = np.shape(A)[1]
    A = A/np.linalg.norm(A, axis=0, keepdims = True)

    B = np.zeros((N_rows,N_vectors))
    count = 0
    ############b
    for j in range (0, N_vectors):
        bvec = Gram_Schdmit_bvec (B[:, :count], A[:, j])
        norm = np.linalg.norm(bvec)
        if norm > 1e-14:
            B[:, count] = bvec/np.linalg.norm(bvec)
            count +=1
    return B[:, :count]

def Gram_Schdmit_fill_holder (V, count, vecs):
    # V is a vectors holder
    # count is the amount of vectors that already sit in the holder

    nvec = np.shape(vecs)[1]
    # amount of new vectors intended to fill in the V

    # count will be final amount of vectors in V
    for j in range (0, nvec):
        vec = vecs[:, j]
        vec = Gram_Schdmit_bvec(V[:, :count], vec)   #single orthonormalize
        vec = Gram_Schdmit_bvec(V[:, :count], vec) #double orthonormalize

        norm = np.linalg.norm(vec)
        if  norm > 1e-14:
            vec = vec/norm
            V[:, count] = vec
            count += 1
    new_count = count

    return V, new_count
########################################################################


####################################################################
# define the orthonormality of a matrix A as the norm of (A.T*A - I)
def check_orthonormal (A):
    n = np.shape(A)[1]
    B = np.dot (A.T, A)
    c = np.linalg.norm(B - np.eye(n))
    return c
####################################################################


########################################################################
def solve_AX_Xla_B (sub_A, eigen_lambda, sub_B):
    # AX - XB  = Q
    N_vectors = len(eigen_lambda)
    a, u = np.linalg.eigh(sub_A)
    ub = np.dot(u.T, sub_B)
    ux = np.zeros_like(sub_B)
    for k in range (N_vectors):
        ux[:, k] = ub[:, k]/(a - eigen_lambda[k])
    sub_guess = np.dot(u, ux)
    return sub_guess
#########################################################################

########################################################################
# sTDA preconditioner
def on_the_fly_sTDA_preconditioner (B, eigen_lambda, current_dic):
    # (sTDA_A - eigen_lambda*I)^-1 B = X
    # AX - X\lambda = B
    # columns in B are residuals (in Davidson's loop) to be preconditioned,
    precondition_start = time.time()

    N_rows = np.shape(B)[0]
    B = B.reshape(N_rows, -1)
    N_vectors = np.shape(B)[1]


    #number of vectors to be preconditioned
    bnorm = np.linalg.norm(B, axis=0, keepdims = True)
    #norm of each vectors in B, shape (1,-1)
    B = B/bnorm

    start = time.time()
    tol = 1e-2    # Convergence tolerance
    max = 30   # Maximum number of iterations

    V = np.zeros((N_rows, (max+1)*N_vectors))
    W = np.zeros((N_rows, (max+1)*N_vectors))
    count = 0

    # now V and W are empty holders, 0 vectors
    # W = sTDA_fly(V)
    # count is the amount of vectors that already sit in the holder
    # in each iteration, V and W will be filled/updated with new guess vectors

    ###########################################
    #initial guess: (diag(A) - \lambda)^-1 B.
    # D is preconditioner for each state
    t = 1e-10
    D = np.repeat(hdiag.reshape(-1,1), N_vectors, axis=1) - eigen_lambda
    D= np.where( abs(D) < t, np.sign(D)*t, D) # <t: returns np.sign(D)*t; else: D
    inv_D = 1/D

    # generate initial guess
    init = B*inv_D
    V, new_count = Gram_Schdmit_fill_holder (V, count, init)
    W[:, count:new_count] = sTDA_fly(V[:, count:new_count])
    count = new_count

    current_dic['step'] = []
    ####################################################################################
    for i in range (0, max):
        sub_B = np.dot(V[:,:count].T, B)
        sub_A = np.dot(V[:,:count].T, W[:,:count])
        #project sTDA_A matrix and vector B into subspace

        # size of subspace
        m = np.shape(sub_A)[0]

        sub_guess = solve_AX_Xla_B(sub_A, eigen_lambda, sub_B)

        full_guess = np.dot(V[:,:count], sub_guess)
        residual = np.dot(W[:,:count], sub_guess) - full_guess*eigen_lambda - B

        Norms_of_r = np.linalg.norm (residual, axis=0, keepdims = False)

        max_norm = np.max(Norms_of_r)

        if max_norm < tol:
            break

        # index for unconverged residuals
        index = [i for i in range(len(Norms_of_r)) if Norms_of_r[i] > tol]


        current_dic['step'].append({'r_norms': Norms_of_r.tolist()})
        current_dic['step'].append({'unconverged_r': len(index)})

        # preconditioning step
        # only generate new guess from unconverged residuals
        new_guess = residual[:,index]*inv_D[:,index]

        V, new_count = Gram_Schdmit_fill_holder (V, count, new_guess)
        W[:, count:new_count] = sTDA_fly(V[:, count:new_count])
        count = new_count

        # V_orthonormality = check_orthonormal(V[:,:count])
        # current_dic['step' + str(i)]['V_orthonormality'] = float(V_orthonormality)

    precondition_end = time.time()
    precondition_time = precondition_end - precondition_start
    if i == (max -1):
        print ('_________________ sTDA Preconditioner Failed Due to Iteration Limmit _________________')
        print ('sTDA preconditioning failed after ', i, 'steps; ', round(precondition_time, 4), 'seconds')
        print ('current residual norms', Norms_of_r)
        print ('max_norm = ', max_norm)
        print ('orthonormality of V', check_orthonormal(V[:,:count]))
    else:
        print ('sTDA Preconditioning Done after ', i, 'steps; ', round(precondition_time, 4), 'seconds')

    return (full_guess*bnorm, current_dic)
###########################################################################################



#############################################
# framework of Davidson's Algorithms
###############################################################################
n = occupied*virtual

def A_diag_initial_guess (k, V):
    # m is size of subspace A matrix, also is the amount of initial guesses
    # m = min([2*k, k+8, occupied*virtual])
    m = k
    sort = hdiag.argsort()
    for j in range(m):
        V[sort[j], j] = 1.0

    return (m, V)

def sTDA_initial_guess (k, V):
    m = k
    #diagonalize sTDA_A amtrix
    V[:, :m] = Davidson0(m)

    return (m, V)
######################################################################################

#####################################################
def A_diag_preconditioner (residual, sub_eigenvalue, current_dic):
    # preconditioners for each corresponding residual
    k = np.shape(residual)[1]

    t = 1e-14

    D = np.repeat(hdiag.reshape(-1,1), k, axis=1) - sub_eigenvalue
    D = np.where( abs(D) < t, np.sign(D)*t, D) # force all values not in domain (-t, t)

    new_guess = residual/D

    return new_guess, current_dic
#######################################################

################################################################################
# original simple Davidson, just to solve eigenvalues and eigenkets of sTDA_A matrix
def Davidson0 (k):

    sTDA_D_start = time.time()
    tol = 1e-2 # Convergence tolerance

    max = 30
    #################################################
    # m is size of subspace
    m = min([2*k, k+8, occupied*virtual])
    V = np.zeros((n, 30*k))
    W = np.zeros((n, 30*k))
    # positions of hdiag with lowest values set as 1

    m, V = A_diag_initial_guess(k, V)

    W[:, :m] = sTDA_fly(V[:, :m])
    # create transformed guess vectors

    #generate initial guess and put in holders V and W
    ###########################################################################################
    for i in range(0, max):
        sub_A = np.dot(V[:,:m].T, W[:,:m])
        sub_eigenvalue, sub_eigenket = np.linalg.eigh(sub_A)
        # Diagonalize the subspace Hamiltonian, and sorted.
        #sub_eigenvalue[:k] are smallest k eigenvalues
        residual = np.dot(W[:,:m], sub_eigenket[:,:k]) - np.dot(V[:,:m], sub_eigenket[:,:k] * sub_eigenvalue[:k])

        Norms_of_r = np.linalg.norm (residual, axis=0, keepdims = True)
        # largest residual norm
        max_norm = np.max(Norms_of_r)
        if max_norm < tol:
            break
        # index for unconverged residuals
        index = [i for i in range(np.shape(Norms_of_r)[1]) if Norms_of_r[0,i] > tol]
        ########################################
        # preconditioning step
        # only generate new guess from unconverged residuals
        Y = None
        new_guess, Y = A_diag_preconditioner (residual[:,index], sub_eigenvalue[:k][index], Y)
        # orthonormalize the new guesses against old guesses and put into V holder
        V, new_m = Gram_Schdmit_fill_holder (V, m, new_guess)
        W[:, m:new_m] = sTDA_fly (V[:, m:new_m])
        m = new_m
    ###########################################################################################
    full_guess = np.dot(V[:,:m], sub_eigenket[:, :k])

    sTDA_D_end = time.time()
    sTDA_D = sTDA_D_end - sTDA_D_start
    print ('sTDA A diagonalization:','threshold =', tol, '; in', i, 'steps ', round(sTDA_D, 4), 'seconds' )
    return (full_guess)
###########################################################################################


################################################################################
# Real Davidson frame, where we can choose different initial guess and preconditioner
def Davidson (k, tol, i, p, Davidson_dic):
    D_start = time.time()

    Davidson_dic['nstate'] = k
    Davidson_dic['molecule'] = basename
    Davidson_dic['method'] = args.method
    Davidson_dic['functional'] = args.functional
    Davidson_dic['threshold'] = tol
    Davidson_dic['iteration'] = []
    iteration_list = Davidson_dic['iteration']



    if i == 'sTDA':
        initial_guess = sTDA_initial_guess
    elif i == 'Adiag':
        initial_guess = A_diag_initial_guess


    if p == 'sTDA':
        precondition = on_the_fly_sTDA_preconditioner
    elif p == 'Adiag':
        precondition = A_diag_preconditioner

    print ('Initial guess:  ', i)
    print ('Preconditioner: ', p)


    n = occupied*virtual
    print ('A matrix size = ', n,'*', n)
    max = 50
    # Maximum number of iterations

    #################################################
    # generate initial guess

    V = np.zeros((n, (max+1)*k))
    W = np.zeros((n, (max+1)*k))
    # positions of hdiag with lowest values set as 1
    # hdiag is non-interacting A matrix

    init_start = time.time ()
    m, V = initial_guess(k, V)
    init_end = time.time ()
    init_time = init_end - init_start

    print ('Intial guess time:', round(init_time, 4), 'seconds')
    #generate initial guess and put in holders V and W
    # m is size of subspace

    # W = Av, create transformed guess vectors
    W[:, :m] = matrix_vector(V[:, :m])

    # time cost for preconditioning
    Pcost = 0
    ###########################################################################################
    for ii in range(0, max):
        print ('Davidson', ii)

        # sub_A is subspace A matrix
        sub_A = np.dot(V[:,:m].T, W[:,:m])

        print ('subspace size: ', np.shape(sub_A)[0])

        sub_eigenvalue, sub_eigenket = np.linalg.eigh(sub_A)
        # Diagonalize the subspace Hamiltonian, and sorted.
        #sub_eigenvalue[:k] are smallest k eigenvalues
        full_guess = np.dot(V[:,:m], sub_eigenket[:, :k])

        residual = np.dot(W[:,:m], sub_eigenket[:,:k]) - full_guess * sub_eigenvalue[:k]

        Norms_of_r = np.linalg.norm (residual, axis=0, keepdims = True)

        # largest residual norm
        max_norm = np.max(Norms_of_r)

        if max_norm < tol:
            print ('All guesses converged!')
            break

        # index for unconverged residuals
        index = [i for i in range(np.shape(Norms_of_r)[1]) if Norms_of_r[0,i] > tol]

        iteration_list.append({})
        current_dic = iteration_list[ii]
        current_dic['total_residuals'] = len(index)
        ########################################
        # preconditioning step
        # only generate new guess from unconverged residuals
        P_start = time.time()
        new_guess, current_dic = precondition (residual[:,index], sub_eigenvalue[:k][index], current_dic)
        P_end = time.time()

        iteration_list[ii] = current_dic

        Pcost += P_end - P_start

        # orthonormalize the new guesses against old guesses and put into V holder
        V, new_m = Gram_Schdmit_fill_holder (V, m, new_guess)
        W[:, m:new_m] = matrix_vector (V[:, m:new_m])
        print ('preconditioned guesses:', new_m - m)
        m = new_m

    D_end = time.time()
    Dcost = D_end - D_start
    Davidson_dic['total time'] = Dcost
    Davidson_dic['precondition time'] = Pcost
    Davidson_dic['iterations'] = ii+1
    ###########################################################################################
    if ii == (max -1):
        print ('============ Davidson Failed Due to Iteration Limmit ==============')
        print ('Davidson failed after ', round(Dcost, 4), 'seconds')
        print ('current residual norms', Norms_of_r)
        print ('max_norm = ', max_norm)

    else:
        print ('Davidson done after ', round(Dcost, 4), 'seconds')
        print ('Total steps =', ii+1)
        print ('Final subspace size = ', np.shape(sub_A))

    print ('Preconditioning time:', round(Pcost, 4), 'seconds')
    return (sub_eigenvalue[:k]*27.21138624598853, full_guess)
################################################################################


if args.compare == True:
    print ('-----------------------------------------------------------------')
    print ('|--------------------    PySCF TDA-TDDFT    ---------------------|')
    td.nstates = args.nstates
    td.conv_tol = 1e-10
    td.verbose = 5
    start = time.time()
    td.kernel()
    end = time.time()
    pyscf_time = end-start
    print ('Built-in Davidson time:', round(pyscf_time, 4), 'seconds')
    print ('|---------------------------------------------------------------|')


option = ['sTDA', 'Adiag']
for i in option:
    for p in option:
        print ('-------------------------------------------------------------------')
        print ('|---------------   In-house Developed Davidson Starts   -----------|')
        print ('Residual convergence threshold =', args.tolerance)
        print ('Number of excited states =', args.nstates)

        total_start = time.time()
        Davidson_dic = {}
        Excitation_energies, kets = Davidson (args.nstates, args.tolerance, i, p, Davidson_dic)
        total_end = time.time()
        total_time = total_end - total_start

        print ('In-house Davidson time:', round(total_time, 4), 'seconds')

        print ('Excited State energies (eV) =')
        print (Excitation_energies)

        curpath = os.path.dirname(os.path.realpath(__file__))
        yamlpath = os.path.join(curpath, basename + 'i_' + i + '_p_'+ p + '.yaml')

        with open(yamlpath, "w", encoding="utf-8") as f:
            yaml.dump(Davidson_dic, f)

        print ('|---------------   In-house Developed Davidson Done   -----------|')
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Quantum', release='19.6.0', version='Darwin Kernel Version 19.6.0: Mon Aug 31 22:12:52 PDT 2020; root:xnu-6153.141.2~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.7.4 (default, Aug 13 2019, 15:17:50) 
[Clang 4.0.1 (tags/RELEASE_401/final)]
numpy 1.17.2  scipy 1.3.1
Date: Thu Oct  8 23:51:04 2020
PySCF version 1.7.3
PySCF path  /Users/zehaozhou/opt/anaconda3/lib/python3.7/site-packages/pyscf

[CONFIG] conf_file None
[INPUT] verbose = 5
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 6
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT]  1 C     -4.891260000000   3.297700000000   0.000290000000 AA   -9.243141804040   6.231749840978   0.000548020576 Bohr
[INPUT]  2 O     -3.493070000000   3.284290000000  -0.003280000000 AA   -6.600945633934   6.206408613648  -0.006198301689 Bohr
[INPUT]  3 H     -5.282130000000   2.583740000000   0.757360000000 AA   -9.981779054349   4.882560977084   1.431202977701 Bohr
[INPUT]  4 H     -5.282130000000   3.054940000000  -1.011610000000 AA   -9.981779054349   5.772999926979  -1.911665844871 Bohr
[INPUT]  5 H     -5.239980000000   4.315400000000   0.271380000000 AA   -9.902127098198   8.154924117948   0.512833875684 Bohr
[INPUT]  6 H     -3.229590000000   2.359810000000  -0.249530000000 AA   -6.103040594634   4.459394606010  -0.471543359863 Bohr
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] O
[INPUT] 0    0    [6    /1   ]  27032.382631      0.00021726302465
                                4052.3871392      0.0016838662199
                                922.3272271       0.0087395616265
                                261.24070989      0.035239968808
                                85.354641351      0.11153519115
                                31.035035245      0.25588953961
[INPUT] 0    0    [2    /1   ]  12.260860728      0.39768730901
                                4.9987076005      0.2462784943
[INPUT] 0    0    [1    /1   ]  1.1703108158         1
[INPUT] 0    0    [1    /1   ]  0.46474740994        1
[INPUT] 0    0    [1    /1   ]  0.18504536357        1
[INPUT] 1    0    [4    /1   ]  63.274954801      0.0060685103418
                                14.627049379      0.041912575824
                                4.4501223456      0.16153841088
                                1.5275799647      0.35706951311
[INPUT] 1    0    [1    /1   ]  0.52935117943        1
[INPUT] 1    0    [1    /1   ]  0.1747842127         1
[INPUT] 2    0    [1    /1   ]  2.314                1
[INPUT] 2    0    [1    /1   ]  0.645                1
[INPUT] 3    0    [1    /1   ]  1.428                1
[INPUT] C
[INPUT] 0    0    [6    /1   ]  13575.349682      0.00022245814352
                                2035.233368       0.0017232738252
                                463.22562359      0.0089255715314
                                131.20019598      0.035727984502
                                42.853015891      0.11076259931
                                15.584185766      0.24295627626
[INPUT] 0    0    [2    /1   ]  6.2067138508      0.41440263448
                                2.5764896527      0.23744968655
[INPUT] 0    0    [1    /1   ]  0.57696339419        1
[INPUT] 0    0    [1    /1   ]  0.22972831358        1
[INPUT] 0    0    [1    /1   ]  0.095164440028       1
[INPUT] 1    0    [4    /1   ]  34.697232244      0.0053333657805
                                7.9582622826      0.035864109092
                                2.3780826883      0.14215873329
                                0.81433208183     0.34270471845
[INPUT] 1    0    [1    /1   ]  0.28887547253        1
[INPUT] 1    0    [1    /1   ]  0.10056823671        1
[INPUT] 2    0    [1    /1   ]  1.097                1
[INPUT] 2    0    [1    /1   ]  0.318                1
[INPUT] 3    0    [1    /1   ]  0.761                1
[INPUT] H
[INPUT] 0    0    [3    /1   ]  34.061341         0.0060251978
                                5.1235746         0.045021094
                                1.1646626         0.20189726
[INPUT] 0    0    [1    /1   ]  0.32723041           1
[INPUT] 0    0    [1    /1   ]  0.10307241           1
[INPUT] 1    0    [1    /1   ]  0.8                  1

nuclear repulsion = 40.3453758822416
number of shells = 38
number of NR pGTOs = 124
number of NR cGTOs = 86
basis = def2-TZVP
ecp = {}
CPU time:         0.78
Molecule built
Calculating SCF Energy...


******** <class 'pyscf.dft.rks.RKS'> ********
method = RKS-RHF
initial guess = minao
damping factor = 0
level_shift factor = 0
DIIS = <class 'pyscf.scf.diis.CDIIS'>
diis_start_cycle = 1
diis_space = 8
SCF conv_tol = 1e-10
SCF conv_tol_grad = None
SCF max_cycles = 50
direct_scf = True
direct_scf_tol = 1e-13
chkfile to save SCF result = /var/folders/yv/2d0zlq3j1dq04l1tjz4qgg800000gn/T/tmp6_7kg08k
max_memory 4000 MB (current use 0 MB)
XC functionals = wb97x
small_rho_cutoff = 1e-07
radial grids: 
    Treutler-Ahlrichs [JCP 102, 346 (1995); DOI:10.1063/1.469408] (M4) radial grids
    
becke partition: Becke, JCP 88, 2547 (1988); DOI:10.1063/1.454033
pruning grids: <function nwchem_prune at 0x7f81fca158c0>
grids dens level: 3
symmetrized grids: False
atomic radii adjust function: <function treutler_atomic_radii_adjust at 0x7f81fca15830>
Set gradient conv threshold to 1e-05
atom C rad-grids = 75, ang-grids = [ 50  50  50  50  50  50  50  50  50  50  50  50  50  50  50  50  50  50
  50  50  50  50  50  86  86  86  86  86  86  86  86  86  86 266 266 266
 266 266 266 266 302 302 302 302 302 302 302 302 302 302 302 302 302 302
 302 302 302 302 302 302 266 266 266 266 266 266 266 266 266 266 266 266
 266 266 266]
atom O rad-grids = 75, ang-grids = [ 50  50  50  50  50  50  50  50  50  50  50  50  50  50  50  50  50  50
  50  50  50  50  86  86  86  86  86  86  86  86  86 266 266 266 266 266
 266 266 302 302 302 302 302 302 302 302 302 302 302 302 302 302 302 302
 302 302 302 266 266 266 266 266 266 266 266 266 266 266 266 266 266 266
 266 266 266]
atom H rad-grids = 50, ang-grids = [ 50  50  50  50  50  50  50  50  50  50  50  50  50  50  86  86  86  86
 266 266 266 266 302 302 302 302 302 302 302 302 302 302 302 302 302 266
 266 266 266 266 266 266 266 266 266 266 266 266 266 266]
tot grids = 68260
Drop grids 8846
    CPU time for setting up grids      0.24 sec, wall time      0.11 sec
nelec by numeric integration = 17.997972355773133
    CPU time for vxc      0.47 sec, wall time      0.26 sec
    CPU time for vj and vk      0.79 sec, wall time      0.39 sec
E1 = -235.33241794971215  Ecoul = 94.54215090762318  Exc = -15.267911041138444
init E= -115.712802200986
cond(S) = 3910.854145644275
    CPU time for initialize scf      2.36 sec, wall time      1.21 sec
  HOMO = -0.361146452294015  LUMO = 0.0468005832949694
  mo_energy =
[-19.40687255 -10.35847317  -1.42785655  -0.96019548  -0.6606058
  -0.56043857  -0.55126456  -0.40179098  -0.36114645   0.04680058
   0.10765704   0.15487797   0.1687169    0.16873004   0.27930312
   0.2851766    0.33118107   0.41481079   0.42654291   0.49000902
   0.4904576    0.51144807   0.53161336   0.54623756   0.60791342
   0.74888579   0.77917195   0.81245983   0.94958724   0.9889365
   1.07341173   1.32235241   1.46433622   1.51076255   1.56403925
   1.57227631   1.58709117   1.61716098   1.63956847   1.73801941
   1.88962022   1.97568245   2.0000728    2.0339806    2.0691939
   2.19608906   2.27314186   2.30207228   2.3152801    2.3574008
   2.43082123   2.53146303   2.5825965    2.64147561   2.75142752
   2.77958986   2.81283806   2.8959681    3.02146825   3.09583147
   3.22898482   3.34564945   3.35541976   3.39964785   3.56423718
   3.57427393   3.59312212   3.90671921   4.10903457   4.17569123
   4.36835145   4.45378152   5.22595879   5.3179487    5.39852956
   5.67994274   5.71899883   5.88824758   6.14338455   6.35767011
   6.58488434   6.65279591   6.8693922    7.04655409  22.2890757
  43.41872846]
nelec by numeric integration = 18.000003273298447
    CPU time for vxc      0.45 sec, wall time      0.23 sec
    CPU time for vj and vk      0.78 sec, wall time      0.39 sec
E1 = -238.44078378192089  Ecoul = 98.05925318215658  Exc = -15.636946210914196
cycle= 1 E= -115.673100928437  delta_E= 0.0397  |g|= 0.587  |ddm|=  1.5
    CPU time for cycle= 1      1.31 sec, wall time      0.66 sec
  HOMO = -0.268424515347733  LUMO = 0.116703238409975
  mo_energy =
[-18.83897719 -10.34735573  -1.04725943  -0.79061747  -0.56991981
  -0.55565393  -0.49631004  -0.34055792  -0.26842452   0.11670324
   0.16044364   0.19571301   0.20140106   0.23335531   0.30195763
   0.31455341   0.42907094   0.46836375   0.49677217   0.53528669
   0.55171455   0.58390184   0.6233037    0.65225356   0.722863
   0.79619753   0.83896867   0.91363598   1.00199356   1.01503375
   1.13084431   1.41162463   1.51467533   1.57354893   1.60399139
   1.60668343   1.63132458   1.68566928   1.73388538   1.80471631
   1.99852928   2.03836565   2.05201175   2.12959751   2.15452492
   2.29325856   2.36360303   2.38989287   2.39827716   2.41568237
   2.54992242   2.56668183   2.63702776   2.72601465   2.84219426
   2.92592579   2.96803054   3.07458987   3.11976383   3.20294139
   3.31656632   3.39589618   3.46777183   3.47987915   3.6534287
   3.65528873   3.67179288   4.04708979   4.16636952   4.24010022
   4.42716437   4.62837319   5.48749389   5.572458     5.65604627
   5.92886086   5.97231846   6.11860744   6.41267211   6.72217256
   6.92827195   7.00316259   7.20564977   7.35613436  22.29796189
  43.94692817]
nelec by numeric integration = 18.00000177341413
    CPU time for vxc      0.43 sec, wall time      0.22 sec
    CPU time for vj and vk      0.78 sec, wall time      0.39 sec
E1 = -235.4530837151497  Ecoul = 94.69819768376267  Exc = -15.261326330823763
cycle= 2 E= -115.670836479969  delta_E= 0.00226  |g|= 0.638  |ddm|= 0.594
    CPU time for cycle= 2      1.28 sec, wall time      0.65 sec
  HOMO = -0.38351042347741  LUMO = 0.110272776705317
  mo_energy =
[-19.20854312 -10.29829126  -1.15585925  -0.80228376  -0.6215385
  -0.55798974  -0.53887162  -0.44136173  -0.38351042   0.11027278
   0.15703755   0.20370585   0.20381957   0.22307852   0.30700925
   0.31127333   0.40819724   0.45415516   0.47769026   0.54043711
   0.54222446   0.56588041   0.59886178   0.60560365   0.66729534
   0.79370245   0.82802723   0.87053166   0.99324021   1.01996623
   1.12358257   1.37859848   1.50707895   1.56570954   1.61577309
   1.61712174   1.63587863   1.66699061   1.70468098   1.78687531
   1.9659225    2.02563238   2.05114325   2.10205561   2.11377307
   2.25536685   2.34973015   2.3575984    2.38807632   2.40212072
   2.50276377   2.57320593   2.63534879   2.6843192    2.82799356
   2.86178122   2.90233445   2.99557003   3.10191698   3.17549001
   3.29433898   3.40740284   3.42886365   3.47018921   3.64285147
   3.64599929   3.65877689   3.9785622    4.17794512   4.24413726
   4.43685885   4.5480688    5.35761398   5.44562054   5.52506175
   5.80419883   5.84675907   6.00117214   6.26955488   6.52936476
   6.74550855   6.82018137   7.02627204   7.18995685  22.3398266
  43.6053303 ]
nelec by numeric integration = 18.00000291094848
    CPU time for vxc      0.42 sec, wall time      0.22 sec
    CPU time for vj and vk      0.78 sec, wall time      0.39 sec
E1 = -237.16168680131017  Ecoul = 96.55336128313243  Exc = -15.472960908537667
cycle= 3 E= -115.735910544474  delta_E= -0.0651  |g|= 0.0307  |ddm|= 0.288
    CPU time for cycle= 3      1.28 sec, wall time      0.65 sec
  HOMO = -0.378630430685058  LUMO = 0.115121718842669
  mo_energy =
[-19.18917786 -10.29862649  -1.14539471  -0.79866684  -0.61616585
  -0.55461347  -0.53592658  -0.43960325  -0.37863043   0.11512172
   0.15982263   0.20528394   0.20591632   0.22585396   0.30972173
   0.31239392   0.41150691   0.45589406   0.4830953    0.54202689
   0.54333215   0.56882183   0.60209076   0.60800478   0.67113095
   0.79622      0.82939556   0.87107638   0.99532894   1.02336086
   1.12630537   1.38472544   1.512304     1.5674445    1.61765644
   1.61902557   1.63920841   1.67162522   1.70829445   1.79209518
   1.97069666   2.02980941   2.05393305   2.104838     2.11935065
   2.25951001   2.35464307   2.36164715   2.39118984   2.40514189
   2.50568944   2.57678524   2.63799229   2.69171284   2.83175843
   2.8650858    2.90839759   2.99766844   3.10505332   3.17762559
   3.29821946   3.41021096   3.43331971   3.47311198   3.646571
   3.64866562   3.66178759   3.98829046   4.18109946   4.24664272
   4.44004811   4.55467924   5.36640435   5.45503185   5.53305015
   5.81091168   5.85554727   6.01179181   6.2819855    6.53648124
   6.75349209   6.82645082   7.03310235   7.19581425  22.33965042
  43.62301764]
nelec by numeric integration = 18.000002935578898
    CPU time for vxc      0.43 sec, wall time      0.22 sec
    CPU time for vj and vk      0.78 sec, wall time      0.39 sec
E1 = -237.08328058085667  Ecoul = 96.46649588790451  Exc = -15.464676090317965
cycle= 4 E= -115.736084901029  delta_E= -0.000174  |g|= 0.00983  |ddm|= 0.0224
    CPU time for cycle= 4      1.29 sec, wall time      0.65 sec
  HOMO = -0.380548361335757  LUMO = 0.114764056006014
  mo_energy =
[-19.1938474  -10.2992429   -1.14816197  -0.79902209  -0.61760547
  -0.55543478  -0.53680454  -0.44050514  -0.38054836   0.11476406
   0.16002687   0.2055972    0.20597591   0.22595722   0.30976278
   0.31276386   0.41107371   0.45580741   0.48240049   0.54186303
   0.54297876   0.56850898   0.60117805   0.60815206   0.67030657
   0.79578726   0.82916367   0.8704709    0.99507997   1.02290456
   1.12604358   1.38368697   1.51169369   1.56751663   1.61743521
   1.61934271   1.63878562   1.67102816   1.70764166   1.79136849
   1.9698173    2.02931441   2.05422807   2.10419596   2.11869023
   2.25878454   2.35387688   2.36143309   2.39086124   2.40524364
   2.50521854   2.57676724   2.63802183   2.69074266   2.83140646
   2.86431678   2.90686958   2.99665743   3.10428713   3.1772566
   3.29796088   3.40984849   3.43241589   3.47278627   3.64601342
   3.64835651   3.661422     3.98653193   4.18081002   4.24697329
   4.43999983   4.55314791   5.3639552    5.45247126   5.53093758
   5.80920838   5.85324322   6.00935725   6.27924078   6.53371079
   6.75066133   6.82381004   7.0306315    7.19377961  22.33895838
  43.6186667 ]
nelec by numeric integration = 18.00000297073129
    CPU time for vxc      0.45 sec, wall time      0.23 sec
    CPU time for vj and vk      0.79 sec, wall time      0.40 sec
E1 = -237.10962196521552  Ecoul = 96.49613341092662  Exc = -15.467991694354701
cycle= 5 E= -115.736104366402  delta_E= -1.95e-05  |g|= 0.00128  |ddm|= 0.00773
    CPU time for cycle= 5      1.31 sec, wall time      0.67 sec
  HOMO = -0.380371988477903  LUMO = 0.114875503480649
  mo_energy =
[-19.19384042 -10.29808898  -1.14801148  -0.79873775  -0.6173911
  -0.55513557  -0.53661383  -0.44033686  -0.38037199   0.1148755
   0.16010628   0.20568632   0.2061123    0.22603267   0.30988734
   0.31283387   0.41124311   0.45595147   0.4824795    0.54204702
   0.54308214   0.568677     0.60128527   0.60824907   0.6703508
   0.7959649    0.82931489   0.87055558   0.99520966   1.02307919
   1.12624762   1.38380305   1.51183899   1.56767899   1.61774387
   1.61946227   1.63907399   1.67118818   1.70779949   1.79156111
   1.96993743   2.02946141   2.05429847   2.10436221   2.11885514
   2.25887395   2.35404044   2.36147488   2.39104463   2.40540679
   2.50528355   2.57694308   2.63824687   2.69083663   2.83158368
   2.86445037   2.90707194   2.99686349   3.10472265   3.17761685
   3.29815744   3.41017544   3.43265383   3.47307488   3.64631927
   3.64866194   3.66173228   3.98667092   4.18118731   4.24719115
   4.44032357   4.55335932   5.36404417   5.45257823   5.53097766
   5.80930253   5.85337859   6.00951684   6.27929404   6.53376337
   6.75075164   6.82390854   7.03071249   7.19382879  22.33997728
  43.61869818]
nelec by numeric integration = 18.00000297827788
    CPU time for vxc      0.44 sec, wall time      0.23 sec
    CPU time for vj and vk      0.78 sec, wall time      0.39 sec
E1 = -237.10693615588687  Ecoul = 96.49325512146272  Exc = -15.467799623677696
cycle= 6 E= -115.73610477586  delta_E= -4.09e-07  |g|= 0.00047  |ddm|= 0.0015
    CPU time for cycle= 6      1.29 sec, wall time      0.66 sec
  HOMO = -0.380453039159048  LUMO = 0.114851753660669
  mo_energy =
[-19.19404169 -10.29849564  -1.14812238  -0.79885467  -0.61749111
  -0.55524464  -0.53672617  -0.44042836  -0.38045304   0.11485175
   0.16007571   0.20564263   0.20606903   0.22599084   0.30986096
   0.31280478   0.41116715   0.45588374   0.4824247    0.54198119
   0.54304158   0.56860538   0.60123354   0.60819135   0.67031341
   0.79588941   0.82924746   0.8705146    0.99514126   1.02300878
   1.12614467   1.3837381    1.51176866   1.56757212   1.61762627
   1.61939083   1.63896615   1.67111717   1.70773126   1.791478
   1.96986765   2.02939231   2.05422396   2.10428672   2.11879042
   2.25881634   2.35395134   2.36141487   2.39097547   2.40534443
   2.505224     2.57686998   2.63815851   2.69078426   2.83148958
   2.86436465   2.90696663   2.99674889   3.10454809   3.17745332
   3.29803897   3.4100436    3.43254351   3.47294124   3.64617551
   3.64853232   3.66159772   3.98659579   4.1810613    4.24706139
   4.44019813   4.55323028   5.36395396   5.45248605   5.53089079
   5.8091809    5.85325649   6.00939074   6.27920193   6.53365441
   6.75064588   6.82380597   7.03059714   7.19371954  22.33960751
  43.6185134 ]
nelec by numeric integration = 18.000002979233145
    CPU time for vxc      0.44 sec, wall time      0.23 sec
    CPU time for vj and vk      0.78 sec, wall time      0.39 sec
E1 = -237.10891611124308  Ecoul = 96.49544110985532  Exc = -15.468005709707937
cycle= 7 E= -115.736104828854  delta_E= -5.3e-08  |g|= 9.05e-05  |ddm|= 0.000399
    CPU time for cycle= 7      1.29 sec, wall time      0.66 sec
  HOMO = -0.380449928126621  LUMO = 0.114852470948822
  mo_energy =
[-19.19405864 -10.29844679  -1.14811687  -0.79884075  -0.6174845
  -0.55523349  -0.53671172  -0.44042108  -0.38044993   0.11485247
   0.16008123   0.2056519    0.2060733    0.22599607   0.30986501
   0.31281531   0.41117576   0.45589189   0.48242838   0.54199026
   0.54304425   0.56861207   0.60123743   0.60820051   0.67031387
   0.795899     0.82925586   0.87052208   0.99515266   1.02301717
   1.126158     1.38374143   1.51177318   1.56758992   1.61764037
   1.61940111   1.638978     1.67112473   1.70773641   1.79148701
   1.96987174   2.0293996    2.05423689   2.1042928    2.11879256
   2.25882048   2.35395972   2.36142203   2.39098001   2.40535046
   2.50522857   2.57687908   2.63816954   2.69078274   2.83150048
   2.86437037   2.90697404   2.99675657   3.10456997   3.17747426
   3.29805601   3.41006097   3.4325541    3.47296059   3.64619224
   3.64854921   3.66161367   3.98659652   4.18107449   4.24708454
   4.44021453   4.55324289   5.36395585   5.45248793   5.53089278
   5.80918946   5.85326446   6.00939715   6.27920095   6.53365348
   6.75064367   6.82380247   7.03059478   7.19371855  22.33965211
  43.61849931]
nelec by numeric integration = 18.000002979847153
    CPU time for vxc      0.43 sec, wall time      0.22 sec
    CPU time for vj and vk      0.80 sec, wall time      0.40 sec
E1 = -237.1088263070476  Ecoul = 96.49534863646468  Exc = -15.468003043288302
cycle= 8 E= -115.73610483163  delta_E= -2.78e-09  |g|= 1.29e-05  |ddm|= 0.000152
    CPU time for cycle= 8      1.31 sec, wall time      0.66 sec
  HOMO = -0.380449134171857  LUMO = 0.114853944939995
  mo_energy =
[-19.19405529 -10.29844306  -1.14811568  -0.79883907  -0.61748352
  -0.55523198  -0.53671124  -0.44042045  -0.38044913   0.11485394
   0.16008216   0.20565241   0.206074     0.22599668   0.30986633
   0.31281531   0.41117651   0.45589292   0.48242965   0.54199114
   0.54304475   0.5686131    0.60123841   0.60820107   0.67031482
   0.79589993   0.82925668   0.87052218   0.99515313   1.02301804
   1.12615927   1.38374309   1.51177499   1.56759089   1.61764187
   1.61940181   1.63897981   1.67112619   1.70773799   1.79148838
   1.96987312   2.02940078   2.05423721   2.10429395   2.11879452
   2.25882168   2.35396121   2.36142275   2.39098156   2.40535197
   2.50522932   2.57688017   2.63817077   2.6907845    2.83150168
   2.86437167   2.90697542   2.99675773   3.10457165   3.17747586
   3.29805651   3.41006186   3.43255552   3.47296163   3.64619342
   3.64855062   3.66161496   3.98659859   4.18107643   4.24708512
   4.44021573   4.55324384   5.36395699   5.45248901   5.53089465
   5.80919064   5.85326501   6.0093982    6.27920349   6.53365446
   6.75064478   6.82380425   7.03059665   7.19371973  22.33965562
  43.61850232]
nelec by numeric integration = 18.000002979977832
    CPU time for vxc      0.44 sec, wall time      0.23 sec
    CPU time for vj and vk      0.80 sec, wall time      0.40 sec
E1 = -237.10881622435994  Ecoul = 96.49533701495945  Exc = -15.468001504581267
cycle= 9 E= -115.73610483174  delta_E= -1.11e-10  |g|= 2.39e-06  |ddm|= 4.23e-05
    CPU time for cycle= 9      1.32 sec, wall time      0.67 sec
  HOMO = -0.380449399085257  LUMO = 0.114853796289561
  mo_energy =
[-19.19405545 -10.29844389  -1.14811591  -0.79883949  -0.61748372
  -0.5552321   -0.53671158  -0.44042073  -0.3804494    0.1148538
   0.16008206   0.20565239   0.20607391   0.22599652   0.30986625
   0.31281518   0.4111763    0.45589273   0.48242944   0.54199107
   0.54304454   0.56861294   0.60123822   0.60820089   0.67031452
   0.79589976   0.82925651   0.87052204   0.99515303   1.02301794
   1.12615908   1.38374277   1.5117747    1.56759057   1.61764164
   1.61940164   1.63897958   1.67112603   1.70773791   1.79148815
   1.96987282   2.0294006    2.05423698   2.10429377   2.11879436
   2.25882149   2.35396095   2.36142246   2.39098143   2.4053519
   2.50522913   2.57688004   2.63817065   2.69078425   2.83150142
   2.86437135   2.90697525   2.99675752   3.10457125   3.1774755
   3.29805631   3.41006172   3.4325553    3.47296149   3.64619313
   3.64855033   3.66161465   3.98659827   4.18107619   4.24708477
   4.44021554   4.55324368   5.36395669   5.45248871   5.53089433
   5.80919045   5.85326481   6.00939797   6.27920306   6.5336542
   6.75064448   6.82380387   7.03059631   7.19371954  22.33965486
  43.6185021 ]
nelec by numeric integration = 18.00000297999917
    CPU time for vxc      0.45 sec, wall time      0.23 sec
    CPU time for vj and vk      0.86 sec, wall time      0.44 sec
E1 = -237.10881731648948  Ecoul = 96.49533828264188  Exc = -15.46800168013812
cycle= 10 E= -115.736104831744  delta_E= -3.95e-12  |g|= 5.39e-07  |ddm|= 8.87e-06
    CPU time for cycle= 10      1.39 sec, wall time      0.71 sec
  HOMO = -0.380449394414342  LUMO = 0.114853781869689
  mo_energy =
[-19.19405534 -10.29844373  -1.14811591  -0.79883944  -0.61748372
  -0.55523209  -0.53671153  -0.44042071  -0.38044939   0.11485378
   0.16008207   0.20565241   0.20607388   0.22599651   0.30986623
   0.31281518   0.41117628   0.45589274   0.48242945   0.54199107
   0.54304453   0.56861294   0.60123822   0.6082009    0.67031453
   0.79589976   0.8292565    0.87052202   0.99515303   1.02301794
   1.1261591    1.38374278   1.51177471   1.56759063   1.61764164
   1.61940166   1.6389796    1.67112604   1.7077379    1.79148815
   1.96987283   2.0294006    2.05423701   2.10429376   2.11879436
   2.25882149   2.35396098   2.36142249   2.39098142   2.4053519
   2.50522914   2.57688005   2.63817065   2.69078426   2.83150145
   2.86437138   2.90697525   2.99675753   3.10457129   3.17747554
   3.29805634   3.41006172   3.43255531   3.47296151   3.64619316
   3.64855036   3.66161467   3.98659828   4.18107619   4.24708483
   4.44021556   4.55324368   5.36395669   5.4524887    5.53089435
   5.80919046   5.8532648    6.00939797   6.2792031    6.53365421
   6.7506445    6.82380391   7.03059635   7.19371954  22.339655
  43.61850219]
nelec by numeric integration = 18.000002980002314
    CPU time for vxc      0.46 sec, wall time      0.24 sec
    CPU time for vj and vk      0.84 sec, wall time      0.42 sec
E1 = -237.10881660069424  Ecoul = 96.49533746757567  Exc = -15.46800158086772
Extra cycle  E= -115.736104831745  delta_E= -5.97e-13  |g|= 1.83e-07  |ddm|= 1.92e-06
    CPU time for scf_cycle     16.80 sec, wall time      8.56 sec
    CPU time for SCF     16.80 sec, wall time      8.57 sec
converged SCF energy = -115.736104831745
SCF Done after  8.5688 seconds
Converting <class 'pyscf.dft.rks.RKS'> to RHF
Q-Gamma tensors building time = 0.2809
-------------------------------------------------------------------
|---------------   In-house Developed Davidson Starts   -----------|
Residual convergence threshold = 1e-05
Number of excited states = 4
Initial guess:   sTDA
Preconditioner:  sTDA
A matrix size =  693 * 693
sTDA A diagonalization: threshold = 0.01 ; in 4 steps  0.0076 seconds
Intial guess time: 0.0078 seconds
    CPU time for vj and vk      1.38 sec, wall time      0.70 sec
Davidson 0
subspace size:  4
sTDA Preconditioning Done after  14 steps;  0.0212 seconds
    CPU time for vj and vk      1.36 sec, wall time      0.68 sec
preconditioned guesses: 4
Davidson 1
subspace size:  8
sTDA Preconditioning Done after  16 steps;  0.0247 seconds
    CPU time for vj and vk      1.35 sec, wall time      0.68 sec
preconditioned guesses: 4
Davidson 2
subspace size:  12
sTDA Preconditioning Done after  11 steps;  0.0155 seconds
    CPU time for vj and vk      1.43 sec, wall time      0.73 sec
preconditioned guesses: 4
Davidson 3
subspace size:  16
sTDA Preconditioning Done after  13 steps;  0.0195 seconds
    CPU time for vj and vk      1.34 sec, wall time      0.67 sec
preconditioned guesses: 4
Davidson 4
subspace size:  20
sTDA Preconditioning Done after  14 steps;  0.0227 seconds
    CPU time for vj and vk      1.36 sec, wall time      0.69 sec
preconditioned guesses: 4
Davidson 5
subspace size:  24
sTDA Preconditioning Done after  18 steps;  0.0238 seconds
    CPU time for vj and vk      1.24 sec, wall time      0.63 sec
preconditioned guesses: 3
Davidson 6
subspace size:  27
sTDA Preconditioning Done after  16 steps;  0.0252 seconds
    CPU time for vj and vk      1.21 sec, wall time      0.61 sec
preconditioned guesses: 3
Davidson 7
subspace size:  30
sTDA Preconditioning Done after  16 steps;  0.0191 seconds
    CPU time for vj and vk      1.05 sec, wall time      0.53 sec
preconditioned guesses: 2
Davidson 8
subspace size:  32
sTDA Preconditioning Done after  15 steps;  0.0139 seconds
    CPU time for vj and vk      0.89 sec, wall time      0.45 sec
preconditioned guesses: 1
Davidson 9
subspace size:  33
All guesses converged!
Davidson done after  12.9933 seconds
Total steps = 10
Final subspace size =  (33, 33)
Preconditioning time: 0.1867 seconds
In-house Davidson time: 12.996 seconds
Excited State energies (eV) =
[ 7.27972926  9.21029779  9.30840415 10.16887979]
|---------------   In-house Developed Davidson Done   -----------|
-------------------------------------------------------------------
|---------------   In-house Developed Davidson Starts   -----------|
Residual convergence threshold = 1e-05
Number of excited states = 4
Initial guess:   sTDA
Preconditioner:  Adiag
A matrix size =  693 * 693
sTDA A diagonalization: threshold = 0.01 ; in 4 steps  0.0057 seconds
Intial guess time: 0.0057 seconds
    CPU time for vj and vk      1.36 sec, wall time      0.69 sec
Davidson 0
subspace size:  4
    CPU time for vj and vk      1.35 sec, wall time      0.68 sec
preconditioned guesses: 4
Davidson 1
subspace size:  8
    CPU time for vj and vk      1.38 sec, wall time      0.70 sec
preconditioned guesses: 4
Davidson 2
subspace size:  12
    CPU time for vj and vk      1.34 sec, wall time      0.67 sec
preconditioned guesses: 4
Davidson 3
subspace size:  16
    CPU time for vj and vk      1.34 sec, wall time      0.67 sec
preconditioned guesses: 4
Davidson 4
subspace size:  20
    CPU time for vj and vk      1.35 sec, wall time      0.68 sec
preconditioned guesses: 4
Davidson 5
subspace size:  24
    CPU time for vj and vk      1.34 sec, wall time      0.67 sec
preconditioned guesses: 4
Davidson 6
subspace size:  28
    CPU time for vj and vk      1.15 sec, wall time      0.58 sec
preconditioned guesses: 3
Davidson 7
subspace size:  31
    CPU time for vj and vk      1.15 sec, wall time      0.58 sec
preconditioned guesses: 3
Davidson 8
subspace size:  34
    CPU time for vj and vk      1.11 sec, wall time      0.57 sec
preconditioned guesses: 2
Davidson 9
subspace size:  36
    CPU time for vj and vk      1.03 sec, wall time      0.52 sec
preconditioned guesses: 2
Davidson 10
subspace size:  38
    CPU time for vj and vk      0.94 sec, wall time      0.47 sec
preconditioned guesses: 1
Davidson 11
subspace size:  39
All guesses converged!
Davidson done after  14.7772 seconds
Total steps = 12
Final subspace size =  (39, 39)
Preconditioning time: 0.001 seconds
In-house Davidson time: 14.7809 seconds
Excited State energies (eV) =
[ 7.27972926  9.21029779  9.30840415 10.16887979]
|---------------   In-house Developed Davidson Done   -----------|
-------------------------------------------------------------------
|---------------   In-house Developed Davidson Starts   -----------|
Residual convergence threshold = 1e-05
Number of excited states = 4
Initial guess:   Adiag
Preconditioner:  sTDA
A matrix size =  693 * 693
Intial guess time: 0.0 seconds
    CPU time for vj and vk      1.30 sec, wall time      0.65 sec
Davidson 0
subspace size:  4
sTDA Preconditioning Done after  15 steps;  0.0229 seconds
    CPU time for vj and vk      1.31 sec, wall time      0.66 sec
preconditioned guesses: 4
Davidson 1
subspace size:  8
sTDA Preconditioning Done after  14 steps;  0.0197 seconds
    CPU time for vj and vk      1.30 sec, wall time      0.65 sec
preconditioned guesses: 4
Davidson 2
subspace size:  12
sTDA Preconditioning Done after  12 steps;  0.0164 seconds
    CPU time for vj and vk      1.31 sec, wall time      0.66 sec
preconditioned guesses: 4
Davidson 3
subspace size:  16
sTDA Preconditioning Done after  15 steps;  0.0228 seconds
    CPU time for vj and vk      1.34 sec, wall time      0.68 sec
preconditioned guesses: 4
Davidson 4
subspace size:  20
sTDA Preconditioning Done after  15 steps;  0.0202 seconds
    CPU time for vj and vk      1.42 sec, wall time      0.73 sec
preconditioned guesses: 4
Davidson 5
subspace size:  24
sTDA Preconditioning Done after  14 steps;  0.0186 seconds
    CPU time for vj and vk      1.14 sec, wall time      0.57 sec
preconditioned guesses: 3
Davidson 6
subspace size:  27
sTDA Preconditioning Done after  18 steps;  0.0192 seconds
    CPU time for vj and vk      1.02 sec, wall time      0.51 sec
preconditioned guesses: 2
Davidson 7
subspace size:  29
sTDA Preconditioning Done after  19 steps;  0.0213 seconds
    CPU time for vj and vk      1.05 sec, wall time      0.53 sec
preconditioned guesses: 2
Davidson 8
subspace size:  31
sTDA Preconditioning Done after  16 steps;  0.0167 seconds
    CPU time for vj and vk      0.99 sec, wall time      0.49 sec
preconditioned guesses: 2
Davidson 9
subspace size:  33
All guesses converged!
Davidson done after  12.5887 seconds
Total steps = 10
Final subspace size =  (33, 33)
Preconditioning time: 0.1791 seconds
In-house Davidson time: 12.5888 seconds
Excited State energies (eV) =
[ 7.27972926  9.21029779  9.30840415 10.16887979]
|---------------   In-house Developed Davidson Done   -----------|
-------------------------------------------------------------------
|---------------   In-house Developed Davidson Starts   -----------|
Residual convergence threshold = 1e-05
Number of excited states = 4
Initial guess:   Adiag
Preconditioner:  Adiag
A matrix size =  693 * 693
Intial guess time: 0.0 seconds
    CPU time for vj and vk      1.26 sec, wall time      0.63 sec
Davidson 0
subspace size:  4
    CPU time for vj and vk      1.27 sec, wall time      0.63 sec
preconditioned guesses: 4
Davidson 1
subspace size:  8
    CPU time for vj and vk      1.29 sec, wall time      0.65 sec
preconditioned guesses: 4
Davidson 2
subspace size:  12
    CPU time for vj and vk      1.37 sec, wall time      0.69 sec
preconditioned guesses: 4
Davidson 3
subspace size:  16
    CPU time for vj and vk      1.33 sec, wall time      0.67 sec
preconditioned guesses: 4
Davidson 4
subspace size:  20
    CPU time for vj and vk      1.27 sec, wall time      0.64 sec
preconditioned guesses: 4
Davidson 5
subspace size:  24
    CPU time for vj and vk      1.35 sec, wall time      0.68 sec
preconditioned guesses: 4
Davidson 6
subspace size:  28
    CPU time for vj and vk      1.22 sec, wall time      0.62 sec
preconditioned guesses: 3
Davidson 7
subspace size:  31
    CPU time for vj and vk      1.21 sec, wall time      0.61 sec
preconditioned guesses: 3
Davidson 8
subspace size:  34
    CPU time for vj and vk      1.13 sec, wall time      0.58 sec
preconditioned guesses: 2
Davidson 9
subspace size:  36
    CPU time for vj and vk      1.02 sec, wall time      0.51 sec
preconditioned guesses: 2
Davidson 10
subspace size:  38
    CPU time for vj and vk      0.91 sec, wall time      0.46 sec
preconditioned guesses: 1
Davidson 11
subspace size:  39
    CPU time for vj and vk      0.90 sec, wall time      0.45 sec
preconditioned guesses: 1
Davidson 12
subspace size:  40
All guesses converged!
Davidson done after  15.4291 seconds
Total steps = 13
Final subspace size =  (40, 40)
Preconditioning time: 0.0009 seconds
In-house Davidson time: 15.4319 seconds
Excited State energies (eV) =
[ 7.27972926  9.21029779  9.30840415 10.16887979]
|---------------   In-house Developed Davidson Done   -----------|
